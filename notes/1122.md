v 有三个月# 继承-派生类 11.22
## 继承的概念
**基类-派生类**

派生类具有基类的所有特征，也可以定义新的特征，对基类的一些特征进行重定义。

**继承可以分为单继承和多继承（对于CPP）**

单继承：一个类只能有一个直接基类 多继承：一个类可以有多个直接基类
## 继承机制的作用
- 支持软件复用
 把一个或多个已有的类的功能包含进新类中 不需要修改已有的软件代码
 - 对事物进行分类 类与类之间存在一般与特殊的关系`is-a-kind-of` 把类组织称层次结构有利于描述和解决问题
 - 支持软件的增量开发
 - 对概念进行组合

 **在此处添加图片！**

## 单继承
```cpp
class <派生类名>: [<继承方式>] <基类名>
{
    <成员说明表>
}
```

继承方式

public, private, protected

默认为private，一般来说使用public

例子

```cpp
class Bird
{
    Wing lftw, rgtw;
public:
    void fly();
    void walk();
}

class Penguin : pulbic Bird
{
    Skin psk;
public:
    void swim(); //新增成员
}
```

### 几点规定：

- 派生类拥有基类的所有成员（基类的构造函数和赋值操作符重载函数除外），也可以具有新的成员

派生类成员按照基类成员的偏移分布

- 派生类中可以给出**新的成员**，也可以对基类成员进行**重定义**，派生类的访问时对重定义成员的

```cpp
...
    Skin psk;
public:
    void fly()
    {
        error(“Penguins cannot fly”!); //重定义
    }
...
```

- 派生类成员名的作用域嵌套在基类作用域中

派生类的一个成员，在派生类中没有定义与其同名的成员，则该成员名在派生类的作用域中可见；

否则，该成员名在派生类的作用域内不可见，如果要使用，必须用**基类名受限**

即使派生类中定义了与基类同名但**参数不同**的成员函数，基类的同名函数在派生类的作用域中也是不可见的。

例如：

```cpp
...
class Penguin: public Bird
{
    Skin psk;
public:
    void fly();
    void swim();
    void walk() {
        cout << “Wag walk” << endl;
    }
    void move() {
        walk(); //Penguin’s walk
        Bird::walk(); //Bird’s walk
    }
}

Penguin pg;
pg.walk()
pg.Bird::walk()
//另一种方法...
(Bird&) pg.walk() //使编译器将pg视作一个鸟类
...
```

- 定义派生类时一定要见到基类的定义

编译程序无法确定派生类对象需要占用多大内存空间，派生类对基类成员的访问是否合法、对比成员对象（组合、聚合...）

在定义派生类前include包含基类定义的头文件即可

- 友元关系不能继承，需要显式指出

如果在派生类中没有显示说明，基类的友元不是派生类的

- 派生类不能直接访问基类的私有成员

必须要通过基类的非私有成员函数来访问基类的私有成员

public / protected / private

## 类和类之间的关系

### 普通依赖关系

### 聚集关系（aggregation）

部分和整体 is a prt of -— HASA、分层、用...实现

用成员对象的机制实现

飞机类和发动机类的关系

### 公有继承关系（inheritance）

特殊和一般 is a kind of -— ISA

属性和方法（接口）

不同于多边形类和正方形类之间的关系

**Liskov替代法则**

### 组合优于继承

- 避免继承与封装的矛盾
- 聚集可实现运行期动态
- 聚集可避免组合爆炸

## 继承与聚集两种代码复用方式的比较

继承和封装存在矛盾，聚集则没有

在继承方式的代码复用中，一个类通过`protected`访问控制，向外界提供两种接口：
    `public` 对象用户
    `public + protected` 派生类用户

在聚集方式的代码复用中，一个类对外只需一个接口public

## Liskov替换法则
如果一个类型**S**是另一个类型**A**的子类型，则对用**A**表达的所有程序**P**，当用**S**去替换程序**P**中的所有**A**时，程序**P**的功能不变。

**子类型的作用**

- 一个类型的操作也适合于它的子类型

- 一个子类型的值可以赋值或作为函数参数传给基类型变量

> `void f(A)` 和 `void f(A &)`的差别？
>> 第一个接受对象，第二个接受引用，通过的细节：
>> 直接传值:用B构造一个A，B的对象作为一个引用给A的拷贝构造函数，再传入func
>> 传引用：f函数接受了B的对象作为引用


- 发给基类对象的消息也能发给派生类对象（调用函数 = 发送消息）

> `b.func()`的另一种理解？

```cpp
void B::func(B * const this)n
```

- 基类的对象标识可以标识派生类对象

若B是A的派生类，f是A的成员函数，g是B的成员函数：
```cpp
A a, *p;
B b, *q;
//合法
b.f(); 
a = b;  //用b改变a的状态，属于B但不属于A的数据成员将被忽略
p = &b; //A类指针p指向B类对象b
//不合法
b = a; // 导致B有不确定的成员数据（A中没有）
q = &a //导致通过q向a发送它不能处理的消息， 如q->g()
```
